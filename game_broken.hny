# THIS IS BROKEN! DO THIS INCORRECTLY ;)
# Error: 
# Incorrect synchronization in game_umpire
# Game can mistakenly start while not all players who joined have been properly assigned to teams

from synch import Lock, Condition, acquire, release, notify, notifyAll, wait

# returns the initial state of a game object;
def Game() returns game:
    game = {
        .players_waiting: set(),
        .team1: set(),
        .team2: set(),
        .game_lock: Lock(),
        .game_started: Condition(),
        .game_ended: Condition(),
        .game_in_progress: False
    }
    return game

# the code that an umpire thread runs;
def game_umpire(g):
    atomically:
        while True:
            acquire(?g->game_lock)
            # Wait until there are at least two players, but might start prematurely
            if len(g->players_waiting) >= 2:
                notifyAll(?g->game_started)

            all_players = list(g->players_waiting)
            mid_point = len(all_players) // 2
            g->team1 = set(subseq(all_players, 0, mid_point))
            g->team2 = set(subseq(all_players, mid_point, len(all_players)))
            g->players_waiting = set()
            g->game_in_progress = True
            notifyAll(?g->game_ended)
            
            while g->game_in_progress:
                wait(?g->game_ended, ?g->game_lock)
            
            release(?g->game_lock)

# player id wants to join the game. Returns a tuple consisting of team1 and team 2. Every player should see the same tuple of teams;
def game_join(g, id):
    atomically:
        acquire(?g->game_lock)
        g->players_waiting.add(id)
        if len(g->players_waiting) >= 2:
            notify(?g->game_started)
        while (id not in g->team1) and (id not in g->team2):
            wait(?g->game_ended, ?g->game_lock)
        release(?g->game_lock)
        return (g->team1, g->team2)

# player id is done and leaves the game.
def game_leave(g, id):
    atomically:
        acquire(?g->game_lock)
        g->team1.discard(id)
        g->team2.discard(id)
        if (len(g->team1) == 0) and (len(g->team2) == 0):
            g->game_in_progress = False
            notify(?g->game_ended)
        release(?g->game_lock)
